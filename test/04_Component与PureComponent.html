<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>04_component_state</title>
</head>

<body>

  <div id="example"></div>

  <script type="text/javascript" src="./js/react.development.js"></script>
  <script type="text/javascript" src="./js/react-dom.development.js"></script>
  <script type="text/javascript" src="./js/babel.min.js"></script>

  <script type="text/babel">

    /*
  1. Component存在的问题?
      1). 父组件重新render(), 当前组件也会重新执行render(), 即使没有任何变化
      2). 当前组件setState(), 重新执行render(), 即使state没有任何变化

  2. 解决Component存在的问题
      1). 原因: 组件的componentShouldUpdate()默认返回true, 即使数据没有变化render()都会重新执行
      2). 办法1: 重写shouldComponentUpdate(), 判断如果数据有变化返回true, 否则返回false
      3). 办法2: 使用PureComponent代替Component
      4). 说明: 一般都使用PureComponent来优化组件性能

  3. PureComponent的基本原理
      1). 重写实现shouldComponentUpdate()
      2). 对组件的新/旧state和props中的数据进行浅比较, 如果都没有变化, 返回false, 否则返回true
      3). 一旦componentShouldUpdate()返回false不再执行用于更新的render()

  4. 面试题:
      组件的哪个生命周期勾子能实现组件优化?
      PureComponent的原理?
      区别Component与PureComponent?
   */

  class A extends React.Component {

    state = {
      m1: {count:1}
    }

    test1 = () => {
      // 1.
      this.setState(state=>({
        m1:{count:state.m1.count+1}
      })) 
      /*
      这里的m1基于原来的m1去改的，
      改为后的m1，和原来的m1不是同一个对象，
      只是他的count属性是原来的state中的m1.count加了1
      */
      
      
      // const {m1} = this.state
      // m1.count = 2

      /*
      2.只改变对象内部属性的值，对象指向并没有改变，
      在shouldComponentUpdate()的 this.props.m1===nextProps.m1 条件判断中，判断不出来对象内部属性的值是否发生变化(因为是同一个对象嘛，进行的是浅比较)
      所以 this.props.m1===nextProps.m1 为true，即使this.props.m1.count = 1 而 nextProps.m1.count = 2
      */ 
      // this.setState({m1})

      /*
      3.this.setState({m1:{...m1}}) // {...m1}已经是另一个对象了，{...m1}是改变后的this.state.m1中数据的拷贝到新的 {} 里面而得到的对象，根this.state.m1不是同一个对象，也就是指向发生改变了
      在shouldComponentUpdate()的 this.props.m1===nextProps.m1 条件判断中，this.props.m1是之前的A组件状态中的m1对象，nextProps.m1是{...m1}，它们不是同一个对象 
      所以 this.props.m1===nextProps.m1 为false
      */ 

      // this.setState({})
    }


    

    render() {
      console.log('A render()')
      return (
        <div>
          <h1>A组件: m1.count={this.state.m1.count}</h1>
          <button onClick={this.test1}>A 测试1</button>
          <B m1={this.state.m1}/>
        </div>
      )
    }
  }

  class B extends React.Component {

    state = {
      m2: 1
    }

    test2 = () => {
      // this.setState(state=>({
      //   m2:state.m2 + 1
      // }))
      this.setState({})
    }

    // 当前组件是否应该重新render()，如果返回true，就会重新render，否则结束
    shouldComponentUpdate(nextProps,nextState){
      // nextProps 接收的属性
      // nextState 自身的状态
      console.log('shouldComponentUpdate()')


      // 比较新旧props中的和state数据,如果没有一个变化，返回false，否则返回true
      if(this.props.m1===nextProps.m1 && this.state.m2===nextState.m2){
        return false
      }else{
        return true
      }

      //return true // Component中的默认值为true
    }

    render() {
      console.log('B render()')
      return (
        <div>
          <h1>B组件: m2={this.state.m2},m1.count={this.props.m1.count}</h1>
          <button onClick={this.test2}>B 测试2</button>
        </div>
      )
    }
  }

  

  ReactDOM.render(<A/>, document.getElementById('example'))
</script>
</body>

</html>